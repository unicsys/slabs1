<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MBE Architecture - Simplified (No Virtualization)</title>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .top-band {
            background: linear-gradient(135deg, #00695c 0%, #00897b 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .top-band h1 {
            margin: 0;
            font-size: 2.2em;
            font-weight: 300;
        }

        .top-band p {
            margin: 5px 0 0 0;
            font-size: 1.1em;
            opacity: 0.9;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 30px 20px;
        }

        .section {
            background: white;
            margin: 30px 0;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h2 {
            color: #00695c;
            font-size: 1.8em;
            margin-top: 0;
            border-bottom: 3px solid #00897b;
            padding-bottom: 10px;
        }

        h3 {
            color: #00897b;
            font-size: 1.4em;
            margin-top: 25px;
        }

        h4 {
            color: #444;
            font-size: 1.1em;
            margin-top: 20px;
        }

        .architecture-diagram {
            background: #fafafa;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 30px;
            margin: 20px 0;
            text-align: center;
        }

        .layer {
            background: white;
            border: 2px solid #00897b;
            border-radius: 6px;
            padding: 20px;
            margin: 15px 0;
            position: relative;
        }

        .layer-title {
            background: #00897b;
            color: white;
            padding: 8px 15px;
            border-radius: 4px;
            display: inline-block;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .component-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .component {
            background: #e0f2f1;
            border: 1px solid #00897b;
            border-radius: 4px;
            padding: 15px;
            text-align: left;
        }

        .component-title {
            font-weight: 600;
            color: #00695c;
            margin-bottom: 5px;
        }

        .component-desc {
            font-size: 0.9em;
            color: #666;
        }

        .highlight-box {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .warning-box {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .flow-step {
            background: #f1f8e9;
            border-left: 4px solid #689f38;
            padding: 15px 20px;
            margin: 15px 0;
            border-radius: 4px;
        }

        .flow-step-number {
            background: #689f38;
            color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            margin-right: 10px;
        }

        .flow-step-title {
            font-weight: 600;
            color: #33691e;
            font-size: 1.1em;
            margin-bottom: 8px;
        }

        .code-block {
            background: #263238;
            color: #aed581;
            padding: 20px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
            margin: 15px 0;
        }

        .code-comment {
            color: #78909c;
        }

        .code-keyword {
            color: #81c784;
        }

        .code-string {
            color: #fff59d;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th {
            background: #00897b;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 10px 12px;
            border: 1px solid #ddd;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        .arrow-down {
            text-align: center;
            font-size: 2em;
            color: #00897b;
            margin: 10px 0;
        }

        .comparison-table {
            margin: 20px 0;
        }

        .comparison-table td:first-child {
            font-weight: 600;
            background: #e0f2f1;
        }

        .pros {
            color: #2e7d32;
        }

        .cons {
            color: #c62828;
        }

        ul, ol {
            margin: 15px 0;
            padding-left: 30px;
        }

        li {
            margin: 8px 0;
        }
    </style>
</head>
<body>

    <div class="top-band">
        <h1>Simplified Model-Based Enterprise Architecture</h1>
        <p>Knowledge Graph Materialization Approach (No Data Virtualization)</p>
    </div>

    <div class="container">

        <!-- Why This Approach -->
        <div class="section">
            <h2>1. Why Remove Data Virtualization?</h2>
            
            <div class="info-box">
                <strong>Philosophy:</strong> Instead of querying databases on-the-fly (virtualization), we <strong>extract, transform, and load</strong> data into a central knowledge graph that follows the ontology structure.
            </div>

            <h3>Comparison: Virtualization vs. Materialization</h3>
            <table class="comparison-table">
                <tr>
                    <th>Aspect</th>
                    <th>Data Virtualization</th>
                    <th>Knowledge Graph Materialization</th>
                </tr>
                <tr>
                    <td>Data Location</td>
                    <td>Remains in source databases</td>
                    <td class="pros">Copied to central knowledge graph</td>
                </tr>
                <tr>
                    <td>Query Performance</td>
                    <td>Depends on source systems</td>
                    <td class="pros">Fast - optimized graph queries</td>
                </tr>
                <tr>
                    <td>Data Freshness</td>
                    <td class="pros">Real-time</td>
                    <td>Periodic refresh (hourly, daily)</td>
                </tr>
                <tr>
                    <td>Complexity</td>
                    <td>High - requires virtualization middleware</td>
                    <td class="pros">Lower - standard ETL patterns</td>
                </tr>
                <tr>
                    <td>Storage Cost</td>
                    <td class="pros">No additional storage</td>
                    <td>Requires graph database storage</td>
                </tr>
                <tr>
                    <td>Data Governance</td>
                    <td>Complex - data scattered</td>
                    <td class="pros">Easier - centralized validation</td>
                </tr>
                <tr>
                    <td>Best For</td>
                    <td>Real-time operational queries</td>
                    <td class="pros">Analytics, AI/ML, complex graph queries</td>
                </tr>
            </table>

            <div class="highlight-box">
                <strong>✅ When to Use Materialization (This Approach):</strong>
                <ul>
                    <li>Analytics and reporting use cases</li>
                    <li>AI/ML training on integrated data</li>
                    <li>Complex graph traversals and pattern matching</li>
                    <li>When near-real-time (not sub-second) data is acceptable</li>
                    <li>When you want simpler architecture with fewer moving parts</li>
                </ul>
            </div>

            <div class="warning-box">
                <strong>⚠️ When NOT to Use (Consider Virtualization Instead):</strong>
                <ul>
                    <li>Need real-time, sub-second data freshness</li>
                    <li>Cannot copy sensitive data due to compliance</li>
                    <li>Extremely high data volumes (petabytes)</li>
                    <li>Source systems change schemas frequently</li>
                </ul>
            </div>
        </div>

        <!-- Simplified Architecture -->
        <div class="section">
            <h2>2. Four-Layer Simplified Architecture</h2>
            
            <div class="architecture-diagram">
                <div class="layer">
                    <div class="layer-title">Layer 4: Application & Analytics</div>
                    <div class="component-grid">
                        <div class="component">
                            <div class="component-title">Business Applications</div>
                            <div class="component-desc">Dashboards, mobile apps, maintenance systems</div>
                        </div>
                        <div class="component">
                            <div class="component-title">AI/ML Workloads</div>
                            <div class="component-desc">Predictive maintenance, anomaly detection</div>
                        </div>
                        <div class="component">
                            <div class="component-title">Analytics & BI</div>
                            <div class="component-desc">Tableau, Power BI, custom analytics</div>
                        </div>
                        <div class="component">
                            <div class="component-title">Data Scientists</div>
                            <div class="component-desc">Jupyter notebooks, direct graph queries</div>
                        </div>
                    </div>
                </div>

                <div class="arrow-down">↓ Query ↓</div>

                <div class="layer">
                    <div class="layer-title">Layer 3: Knowledge Graph & Semantic API</div>
                    <div class="component-grid">
                        <div class="component">
                            <div class="component-title">Knowledge Graph Database</div>
                            <div class="component-desc">Neo4j, Amazon Neptune - stores ontology-structured data</div>
                        </div>
                        <div class="component">
                            <div class="component-title">Semantic Query API</div>
                            <div class="component-desc">GraphQL, REST, SPARQL endpoints</div>
                        </div>
                        <div class="component">
                            <div class="component-title">Ontology Repository</div>
                            <div class="component-desc">OWL files, class definitions, relationships</div>
                        </div>
                        <div class="component">
                            <div class="component-title">Graph Analytics Engine</div>
                            <div class="component-desc">Path finding, pattern matching, graph algorithms</div>
                        </div>
                    </div>
                </div>

                <div class="arrow-down">↑ ETL Pipeline ↑</div>

                <div class="layer">
                    <div class="layer-title">Layer 2: ETL/ELT Orchestration</div>
                    <div class="component-grid">
                        <div class="component">
                            <div class="component-title">Orchestration Engine</div>
                            <div class="component-desc">Apache Airflow, Prefect - schedule and monitor pipelines</div>
                        </div>
                        <div class="component">
                            <div class="component-title">Semantic Transformations</div>
                            <div class="component-desc">Map database columns to ontology classes</div>
                        </div>
                        <div class="component">
                            <div class="component-title">Data Quality Validation</div>
                            <div class="component-desc">Validate against ontology rules</div>
                        </div>
                        <div class="component">
                            <div class="component-title">Change Data Capture</div>
                            <div class="component-desc">Detect changes in source systems</div>
                        </div>
                    </div>
                </div>

                <div class="arrow-down">↑ Extract ↑</div>

                <div class="layer">
                    <div class="layer-title">Layer 1: Physical Data Sources</div>
                    <div class="component-grid">
                        <div class="component">
                            <div class="component-title">Hawkeye System</div>
                            <div class="component-desc">MaintDB_East.ENGINE_DEFECTS</div>
                        </div>
                        <div class="component">
                            <div class="component-title">Axon System</div>
                            <div class="component-desc">WorkOrderDB.MAINTENANCE_LOG</div>
                        </div>
                        <div class="component">
                            <div class="component-title">Databricks</div>
                            <div class="component-desc">AssetTracker_DB.SERVICE_RECORDS</div>
                        </div>
                        <div class="component">
                            <div class="component-title">Other Systems</div>
                            <div class="component-desc">SAP, ERP, IoT sensors, etc.</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="highlight-box">
                <strong>Key Difference:</strong> Data flows ONE WAY - from source databases → ETL → Knowledge Graph. Applications query the knowledge graph directly, not the source databases.
            </div>
        </div>

        <!-- ETL Pipeline Architecture -->
        <div class="section">
            <h2>3. ETL Pipeline Architecture - The Heart of the System</h2>

            <h3>3.1 Pipeline Overview</h3>
            <div class="flow-step">
                <span class="flow-step-number">1</span>
                <div style="display: inline-block; vertical-align: top; width: calc(100% - 50px);">
                    <div class="flow-step-title">Extract</div>
                    <p>Connect to source databases and extract relevant data:</p>
                    <ul>
                        <li>Full load: Initial extraction of all historical data</li>
                        <li>Incremental load: Only changed records (using timestamps, CDC)</li>
                        <li>Parallel extraction: Multiple sources simultaneously</li>
                    </ul>
                </div>
            </div>

            <div class="flow-step">
                <span class="flow-step-number">2</span>
                <div style="display: inline-block; vertical-align: top; width: calc(100% - 50px);">
                    <div class="flow-step-title">Transform - Semantic Mapping</div>
                    <p>Apply ontology mappings to transform raw data:</p>
                    <ul>
                        <li>Map columns to ontology properties (ENGINE_SN → AircraftEngineIdentifier.value)</li>
                        <li>Create relationships (Identifier DESIGNATES Engine)</li>
                        <li>Apply data quality rules and validations</li>
                        <li>Resolve entity matching (same engine across systems)</li>
                    </ul>
                </div>
            </div>

            <div class="flow-step">
                <span class="flow-step-number">3</span>
                <div style="display: inline-block; vertical-align: top; width: calc(100% - 50px);">
                    <div class="flow-step-title">Load - Knowledge Graph</div>
                    <p>Load transformed data into knowledge graph:</p>
                    <ul>
                        <li>Create nodes for each ontology class instance</li>
                        <li>Create edges for relationships between entities</li>
                        <li>Add metadata (source system, load timestamp)</li>
                        <li>Index key properties for fast queries</li>
                    </ul>
                </div>
            </div>

            <div class="flow-step">
                <span class="flow-step-number">4</span>
                <div style="display: inline-block; vertical-align: top; width: calc(100% - 50px);">
                    <div class="flow-step-title">Validate & Monitor</div>
                    <p>Post-load validation and monitoring:</p>
                    <ul>
                        <li>Check ontology constraints are satisfied</li>
                        <li>Monitor data quality metrics</li>
                        <li>Alert on anomalies or failures</li>
                        <li>Update data lineage records</li>
                    </ul>
                </div>
            </div>

            <h3>3.2 Scheduling Strategy</h3>
            <table>
                <tr>
                    <th>Data Category</th>
                    <th>Update Frequency</th>
                    <th>Rationale</th>
                </tr>
                <tr>
                    <td>Critical Defects</td>
                    <td>Every 15 minutes</td>
                    <td>Safety-critical, needs near real-time</td>
                </tr>
                <tr>
                    <td>Maintenance Records</td>
                    <td>Hourly</td>
                    <td>Operational data, frequent updates</td>
                </tr>
                <tr>
                    <td>Asset Metadata</td>
                    <td>Daily</td>
                    <td>Slowly changing, infrequent updates</td>
                </tr>
                <tr>
                    <td>Historical Data</td>
                    <td>Weekly</td>
                    <td>Archive data, rarely changes</td>
                </tr>
            </table>
        </div>

        <!-- Implementation Details -->
        <div class="section">
            <h2>4. Implementation Details</h2>

            <h3>4.1 Knowledge Graph Schema (Based on Ontology)</h3>
            <div class="code-block">
<span class="code-comment">// Neo4j Cypher: Create nodes and relationships following ontology</span>

<span class="code-comment">// Node Types (from ontology classes)</span>
<span class="code-keyword">CREATE</span> CONSTRAINT IF NOT EXISTS FOR (n:AircraftEngineIdentifier) 
REQUIRE n.value IS UNIQUE;

<span class="code-keyword">CREATE</span> CONSTRAINT IF NOT EXISTS FOR (n:AircraftEngine) 
REQUIRE n.id IS UNIQUE;

<span class="code-comment">// Example: Load data with ontology structure</span>
<span class="code-keyword">CREATE</span> (identifier:AircraftEngineIdentifier {
  value: <span class="code-string">'E1234'</span>,
  sourceSystem: <span class="code-string">'Hawkeye'</span>,
  sourceTable: <span class="code-string">'MaintDB_East.ENGINE_DEFECTS'</span>,
  loadedAt: datetime(),
  confidence: 1.0
})

<span class="code-keyword">CREATE</span> (engine:AircraftEngine {
  id: <span class="code-string">'engine_e1234'</span>,
  model: <span class="code-string">'PW4000'</span>,
  manufacturer: <span class="code-string">'Pratt & Whitney'</span>,
  type: <span class="code-string">'Material Thing'</span>
})

<span class="code-keyword">CREATE</span> (defect:Defect {
  id: <span class="code-string">'defect_12345'</span>,
  description: <span class="code-string">'Turbine blade erosion detected'</span>,
  severity: <span class="code-string">'High'</span>,
  reportedDate: date(<span class="code-string">'2025-01-15'</span>),
  sourceSystem: <span class="code-string">'Hawkeye'</span>
})

<span class="code-comment">// Relationships (from ontology)</span>
<span class="code-keyword">CREATE</span> (identifier)-[:DESIGNATES]->(engine)
<span class="code-keyword">CREATE</span> (defect)-[:AFFECTS_ENGINE]->(engine)
            </div>

            <h3>4.2 ETL Pipeline Code Example (Apache Airflow)</h3>
            <div class="code-block">
<span class="code-comment"># airflow_dag_engine_etl.py</span>
<span class="code-keyword">from</span> airflow <span class="code-keyword">import</span> DAG
<span class="code-keyword">from</span> airflow.operators.python <span class="code-keyword">import</span> PythonOperator
<span class="code-keyword">from</span> datetime <span class="code-keyword">import</span> datetime, timedelta

<span class="code-comment"># DAG Definition</span>
dag = DAG(
    <span class="code-string">'aircraft_engine_semantic_etl'</span>,
    default_args={
        <span class="code-string">'owner'</span>: <span class="code-string">'data-engineering'</span>,
        <span class="code-string">'retries'</span>: 3,
        <span class="code-string">'retry_delay'</span>: timedelta(minutes=5)
    },
    description=<span class="code-string">'ETL pipeline for aircraft engine data to knowledge graph'</span>,
    schedule_interval=<span class="code-string">'0 * * * *'</span>,  <span class="code-comment"># Hourly</span>
    start_date=datetime(2025, 1, 1),
    catchup=False
)

<span class="code-comment"># Task 1: Extract from Hawkeye</span>
extract_hawkeye = PythonOperator(
    task_id=<span class="code-string">'extract_hawkeye'</span>,
    python_callable=extract_from_hawkeye,
    dag=dag
)

<span class="code-comment"># Task 2: Extract from Axon</span>
extract_axon = PythonOperator(
    task_id=<span class="code-string">'extract_axon'</span>,
    python_callable=extract_from_axon,
    dag=dag
)

<span class="code-comment"># Task 3: Extract from Databricks</span>
extract_databricks = PythonOperator(
    task_id=<span class="code-string">'extract_databricks'</span>,
    python_callable=extract_from_databricks,
    dag=dag
)

<span class="code-comment"># Task 4: Transform to ontology structure</span>
transform = PythonOperator(
    task_id=<span class="code-string">'transform_semantic'</span>,
    python_callable=transform_to_ontology,
    dag=dag
)

<span class="code-comment"># Task 5: Load to knowledge graph</span>
load_kg = PythonOperator(
    task_id=<span class="code-string">'load_knowledge_graph'</span>,
    python_callable=load_to_neo4j,
    dag=dag
)

<span class="code-comment"># Task 6: Validate</span>
validate = PythonOperator(
    task_id=<span class="code-string">'validate_quality'</span>,
    python_callable=validate_ontology_constraints,
    dag=dag
)

<span class="code-comment"># Define task dependencies</span>
[extract_hawkeye, extract_axon, extract_databricks] >> transform >> load_kg >> validate
            </div>

            <h3>4.3 Semantic Transformation Logic</h3>
            <div class="code-block">
<span class="code-comment"># semantic_transformer.py</span>
<span class="code-keyword">def</span> transform_to_ontology(extracted_data):
    <span class="code-string">"""Transform raw database records to ontology-structured format"""</span>
    
    ontology_data = {
        <span class="code-string">'nodes'</span>: [],
        <span class="code-string">'relationships'</span>: []
    }
    
    <span class="code-keyword">for</span> record <span class="code-keyword">in</span> extracted_data:
        <span class="code-comment"># Map to AircraftEngineIdentifier</span>
        <span class="code-keyword">if</span> record[<span class="code-string">'source'</span>] == <span class="code-string">'Hawkeye'</span>:
            identifier = {
                <span class="code-string">'label'</span>: <span class="code-string">'AircraftEngineIdentifier'</span>,
                <span class="code-string">'properties'</span>: {
                    <span class="code-string">'value'</span>: record[<span class="code-string">'ENGINE_SN'</span>],
                    <span class="code-string">'sourceSystem'</span>: <span class="code-string">'Hawkeye'</span>,
                    <span class="code-string">'sourceTable'</span>: <span class="code-string">'ENGINE_DEFECTS'</span>
                }
            }
        <span class="code-keyword">elif</span> record[<span class="code-string">'source'</span>] == <span class="code-string">'Axon'</span>:
            identifier = {
                <span class="code-string">'label'</span>: <span class="code-string">'AircraftEngineIdentifier'</span>,
                <span class="code-string">'properties'</span>: {
                    <span class="code-string">'value'</span>: record[<span class="code-string">'Engine_ID'</span>].strip().upper(),
                    <span class="code-string">'sourceSystem'</span>: <span class="code-string">'Axon'</span>,
                    <span class="code-string">'sourceTable'</span>: <span class="code-string">'MAINTENANCE_LOG'</span>
                }
            }
        
        ontology_data[<span class="code-string">'nodes'</span>].append(identifier)
        
        <span class="code-comment"># Create relationships</span>
        relationship = {
            <span class="code-string">'type'</span>: <span class="code-string">'DESIGNATES'</span>,
            <span class="code-string">'from'</span>: identifier[<span class="code-string">'properties'</span>][<span class="code-string">'value'</span>],
            <span class="code-string">'to'</span>: <span class="code-string">f"engine_{identifier['properties']['value']}"</span>
        }
        ontology_data[<span class="code-string">'relationships'</span>].append(relationship)
    
    <span class="code-keyword">return</span> ontology_data
            </div>
        </div>

        <!-- Query Examples -->
        <div class="section">
            <h2>5. Querying the Knowledge Graph</h2>

            <h3>5.1 Direct Graph Queries (Cypher - Neo4j)</h3>
            <div class="code-block">
<span class="code-comment">// Query 1: Find all defects for a specific engine</span>
<span class="code-keyword">MATCH</span> (id:AircraftEngineIdentifier {value: <span class="code-string">'E1234'</span>})
      -[:DESIGNATES]->(engine:AircraftEngine)
      <-[:AFFECTS_ENGINE]-(defect:Defect)
<span class="code-keyword">RETURN</span> id.value, defect.description, defect.severity, defect.reportedDate
<span class="code-keyword">ORDER BY</span> defect.reportedDate <span class="code-keyword">DESC</span>

<span class="code-comment">// Query 2: Find maintenance history for an engine</span>
<span class="code-keyword">MATCH</span> (id:AircraftEngineIdentifier {value: <span class="code-string">'E1234'</span>})
      -[:DESIGNATES]->(engine:AircraftEngine)
      <-[:PERFORMED_ON]-(maint:MaintenanceWorkOrder)
<span class="code-keyword">RETURN</span> maint.workOrderNumber, maint.action, maint.completedDate
<span class="code-keyword">ORDER BY</span> maint.completedDate <span class="code-keyword">DESC</span>

<span class="code-comment">// Query 3: Cross-system integration - find engines with high-severity </span>
<span class="code-comment">// defects from ANY source system</span>
<span class="code-keyword">MATCH</span> (defect:Defect {severity: <span class="code-string">'High'</span>})
      -[:AFFECTS_ENGINE]->(engine:AircraftEngine)
      <-[:DESIGNATES]-(id:AircraftEngineIdentifier)
<span class="code-keyword">RETURN</span> id.value, 
       defect.description,
       defect.sourceSystem,
       defect.reportedDate
<span class="code-keyword">ORDER BY</span> defect.reportedDate <span class="code-keyword">DESC</span>

<span class="code-comment">// Query 4: Graph analytics - find patterns</span>
<span class="code-keyword">MATCH</span> path = (defect:Defect)
             -[:AFFECTS_ENGINE]->(engine:AircraftEngine)
             <-[:PERFORMED_ON]-(maint:MaintenanceWorkOrder)
<span class="code-keyword">WHERE</span> defect.severity = <span class="code-string">'High'</span>
  <span class="code-keyword">AND</span> maint.completedDate > defect.reportedDate
<span class="code-keyword">RETURN</span> path
            </div>

            <h3>5.2 Semantic API Layer (GraphQL)</h3>
            <div class="code-block">
<span class="code-comment"># GraphQL Schema for semantic queries</span>
<span class="code-keyword">type</span> AircraftEngineIdentifier {
  value: String!
  sourceSystem: String!
  designates: AircraftEngine!
}

<span class="code-keyword">type</span> AircraftEngine {
  id: ID!
  model: String
  manufacturer: String
  identifiers: [AircraftEngineIdentifier!]!
  defects: [Defect!]!
  maintenanceHistory: [MaintenanceWorkOrder!]!
}

<span class="code-keyword">type</span> Defect {
  id: ID!
  description: String!
  severity: String!
  reportedDate: Date!
  affectsEngine: AircraftEngine!
}

<span class="code-keyword">type</span> Query {
  <span class="code-comment"># Semantic queries using ontology terms</span>
  findEngineByIdentifier(value: String!): AircraftEngine
  findHighSeverityDefects: [Defect!]!
  findEnginesRequiringMaintenance: [AircraftEngine!]!
}

<span class="code-comment"># Example query from application</span>
<span class="code-keyword">query</span> {
  findEngineByIdentifier(value: <span class="code-string">"E1234"</span>) {
    model
    manufacturer
    defects {
      description
      severity
      reportedDate
    }
    maintenanceHistory {
      action
      completedDate
    }
  }
}
            </div>
        </div>

        <!-- Technology Stack -->
        <div class="section">
            <h2>6. Simplified Technology Stack</h2>

            <table>
                <tr>
                    <th>Component</th>
                    <th>Technology Options</th>
                    <th>Recommendation</th>
                </tr>
                <tr>
                    <td><strong>Knowledge Graph Database</strong></td>
                    <td>Neo4j, Amazon Neptune, ArangoDB</td>
                    <td>Neo4j (mature, excellent tooling)</td>
                </tr>
                <tr>
                    <td><strong>ETL Orchestration</strong></td>
                    <td>Apache Airflow, Prefect, Dagster</td>
                    <td>Apache Airflow (industry standard)</td>
                </tr>
                <tr>
                    <td><strong>Ontology Management</strong></td>
                    <td>Protégé, TopBraid, Apache Jena</td>
                    <td>Protégé for editing, Jena for storage</td>
                </tr>
                <tr>
                    <td><strong>API Layer</strong></td>
                    <td>GraphQL, REST (Flask/FastAPI)</td>
                    <td>GraphQL (natural fit for graphs)</td>
                </tr>
                <tr>
                    <td><strong>Data Quality</strong></td>
                    <td>Great Expectations, dbt tests</td>
                    <td>Great Expectations</td>
                </tr>
                <tr>
                    <td><strong>Monitoring</strong></td>
                    <td>Grafana, Datadog, New Relic</td>
                    <td>Grafana (open source, flexible)</td>
                </tr>
                <tr>
                    <td><strong>Change Data Capture</strong></td>
                    <td>Debezium, AWS DMS, custom triggers</td>
                    <td>Debezium (broad database support)</td>
                </tr>
            </table>

            <div class="highlight-box">
                <strong>💡 Recommended Starter Stack:</strong>
                <ul>
                    <li><strong>Knowledge Graph:</strong> Neo4j Community Edition or Aura (cloud)</li>
                    <li><strong>ETL:</strong> Apache Airflow on Kubernetes</li>
                    <li><strong>API:</strong> Python FastAPI + Strawberry GraphQL</li>
                    <li><strong>Monitoring:</strong> Grafana + Prometheus</li>
                    <li><strong>Total Cost:</strong> Can start with ~$2,000/month cloud infrastructure</li>
                </ul>
            </div>
        </div>

        <!-- Implementation Roadmap -->
        <div class="section">
            <h2>7. Implementation Roadmap (Simplified)</h2>

            <h3>Phase 1: Foundation (Weeks 1-4)</h3>
            <div class="flow-step">
                <div class="flow-step-title">Deliverables:</div>
                <ul>
                    <li>✅ Deploy Neo4j knowledge graph (cloud or on-prem)</li>
                    <li>✅ Set up Apache Airflow orchestration</li>
                    <li>✅ Define core ontology (10-15 key classes)</li>
                    <li>✅ Create ontology → Neo4j schema mapping</li>
                    <li>✅ Build ETL for 1 pilot data source (e.g., Hawkeye)</li>
                </ul>
            </div>

            <h3>Phase 2: First Integration (Weeks 5-8)</h3>
            <div class="flow-step">
                <div class="flow-step-title">Deliverables:</div>
                <ul>
                    <li>✅ Add 2 more data sources (Axon, Databricks)</li>
                    <li>✅ Implement entity resolution (match engines across systems)</li>
                    <li>✅ Build GraphQL semantic API</li>
                    <li>✅ Create pilot dashboard consuming knowledge graph</li>
                    <li>✅ Set up monitoring and alerting</li>
                </ul>
            </div>

            <h3>Phase 3: Scale & Optimize (Weeks 9-16)</h3>
            <div class="flow-step">
                <div class="flow-step-title">Deliverables:</div>
                <ul>
                    <li>✅ Implement incremental loading (CDC)</li>
                    <li>✅ Add data quality validation layer</li>
                    <li>✅ Optimize graph queries and indexes</li>
                    <li>✅ Expand ontology to cover more domains</li>
                    <li>✅ Build 3-5 production applications</li>
                    <li>✅ Train users on semantic queries</li>
                </ul>
            </div>

            <h3>Phase 4: Production & Maturity (Weeks 17-24)</h3>
            <div class="flow-step">
                <div class="flow-step-title">Deliverables:</div>
                <ul>
                    <li>✅ Production hardening (HA, DR, security)</li>
                    <li>✅ Add 10+ additional data sources</li>
                    <li>✅ Implement ML features on knowledge graph</li>
                    <li>✅ Advanced graph analytics (PageRank, community detection)</li>
                    <li>✅ Self-service query builder for business users</li>
                </ul>
            </div>
        </div>

        <!-- Data Flow Example -->
        <div class="section">
            <h2>8. Complete Data Flow Example</h2>

            <h3>Scenario: Loading Aircraft Engine Identifiers</h3>

            <div class="flow-step">
                <span class="flow-step-number">1</span>
                <div style="display: inline-block; vertical-align: top; width: calc(100% - 50px);">
                    <div class="flow-step-title">9:00 AM - Airflow Triggers Hourly ETL</div>
                    <pre style="background: #f5f5f5; padding: 10px; margin-top: 5px; border-radius: 4px;">DAG: aircraft_engine_semantic_etl starts
Tasks: extract_hawkeye, extract_axon, extract_databricks run in parallel</pre>
                </div>
            </div>

            <div class="flow-step">
                <span class="flow-step-number">2</span>
                <div style="display: inline-block; vertical-align: top; width: calc(100% - 50px);">
                    <div class="flow-step-title">9:02 AM - Extract from Databases</div>
                    <pre style="background: #f5f5f5; padding: 10px; margin-top: 5px; border-radius: 4px;">Hawkeye: SELECT * FROM ENGINE_DEFECTS WHERE MODIFIED_DATE > '2025-01-30 08:00:00'
Axon: SELECT * FROM MAINTENANCE_LOG WHERE UPDATED_AT > '2025-01-30 08:00:00'
Databricks: SELECT * FROM SERVICE_RECORDS WHERE last_modified > '2025-01-30 08:00:00'

Result: 127 changed records extracted</pre>
                </div>
            </div>

            <div class="flow-step">
                <span class="flow-step-number">3</span>
                <div style="display: inline-block; vertical-align: top; width: calc(100% - 50px);">
                    <div class="flow-step-title">9:03 AM - Transform to Ontology Structure</div>
                    <pre style="background: #f5f5f5; padding: 10px; margin-top: 5px; border-radius: 4px;">Mapping applied:
- ENGINE_SN → AircraftEngineIdentifier.value
- Engine_ID → AircraftEngineIdentifier.value (with TRIM/UPPER)
- Asset_Serial → AircraftEngineIdentifier.value

Entity Resolution:
- E1234 appears in all 3 systems → merge into single graph entity
- E2847 only in Hawkeye → new entity

Validation:
- All identifiers match format ^[A-Z]{1,2}[0-9]{4,6}$
- No duplicates within same source system
✓ All 127 records validated successfully</pre>
                </div>
            </div>

            <div class="flow-step">
                <span class="flow-step-number">4</span>
                <div style="display: inline-block; vertical-align: top; width: calc(100% - 50px);">
                    <div class="flow-step-title">9:05 AM - Load to Neo4j Knowledge Graph</div>
                    <pre style="background: #f5f5f5; padding: 10px; margin-top: 5px; border-radius: 4px;">MERGE 127 AircraftEngineIdentifier nodes
MERGE 45 AircraftEngine nodes
MERGE 82 Defect nodes
CREATE 127 DESIGNATES relationships
CREATE 82 AFFECTS_ENGINE relationships

Load complete: 381 nodes, 209 relationships created/updated
Load time: 2.3 seconds</pre>
                </div>
            </div>

            <div class="flow-step">
                <span class="flow-step-number">5</span>
                <div style="display: inline-block; vertical-align: top; width: calc(100% - 50px);">
                    <div class="flow-step-title">9:06 AM - Post-Load Validation</div>
                    <pre style="background: #f5f5f5; padding: 10px; margin-top: 5px; border-radius: 4px;">Ontology constraint checks:
✓ Every AircraftEngineIdentifier has exactly 1 DESIGNATES relationship
✓ All Defect severity values are in allowed list
✓ All dates are valid and in proper range
✓ No orphaned nodes

Data quality metrics:
- Completeness: 98.2%
- Consistency: 100%
- Timeliness: <10 minutes latency

Pipeline status: SUCCESS
Next run: 10:00 AM</pre>
                </div>
            </div>

            <div class="flow-step">
                <span class="flow-step-number">6</span>
                <div style="display: inline-block; vertical-align: top; width: calc(100% - 50px);">
                    <div class="flow-step-title">9:10 AM - Applications Query Knowledge Graph</div>
                    <pre style="background: #f5f5f5; padding: 10px; margin-top: 5px; border-radius: 4px;">Dashboard query: "Show engines with critical defects"
→ GraphQL API → Neo4j query
→ Results returned from knowledge graph (not source databases!)
→ Response time: 45ms

AI/ML pipeline: "Train predictive maintenance model"
→ Batch graph query for training data
→ 50,000 historical records retrieved
→ Response time: 1.2 seconds</pre>
                </div>
            </div>
        </div>

        <!-- Benefits -->
        <div class="section">
            <h2>9. Benefits of This Simplified Architecture</h2>

            <div class="component-grid" style="margin-top: 20px;">
                <div class="component">
                    <div class="component-title">🚀 Fast Queries</div>
                    <div class="component-desc">Graph database optimized for semantic queries. No complex joins across systems.</div>
                </div>

                <div class="component">
                    <div class="component-title">🔧 Simpler Stack</div>
                    <div class="component-desc">Fewer components than virtualization. Standard ETL patterns that teams understand.</div>
                </div>

                <div class="component">
                    <div class="component-title">📊 Better Analytics</div>
                    <div class="component-desc">Graph algorithms, pattern matching, and ML work better on materialized data.</div>
                </div>

                <div class="component">
                    <div class="component-title">✅ Data Quality</div>
                    <div class="component-desc">Validate and cleanse during ETL. Single source of truth in knowledge graph.</div>
                </div>

                <div class="component">
                    <div class="component-title">🔍 Full Lineage</div>
                    <div class="component-desc">Track exactly where each piece of data came from and when it was loaded.</div>
                </div>

                <div class="component">
                    <div class="component-title">💰 Cost Effective</div>
                    <div class="component-desc">No expensive virtualization license. Use open-source tools for most components.</div>
                </div>
            </div>
        </div>

        <!-- Challenges & Solutions -->
        <div class="section">
            <h2>10. Challenges & Solutions</h2>

            <table>
                <tr>
                    <th>Challenge</th>
                    <th>Solution</th>
                </tr>
                <tr>
                    <td>Data latency (not real-time)</td>
                    <td>Use CDC for near real-time updates. Schedule critical data more frequently (15 min).</td>
                </tr>
                <tr>
                    <td>Storage costs for duplicated data</td>
                    <td>Graph databases compress well. Store only active/relevant data. Archive old records.</td>
                </tr>
                <tr>
                    <td>Initial full load takes time</td>
                    <td>Parallelize extraction. Load incrementally by date ranges. Run during off-peak hours.</td>
                </tr>
                <tr>
                    <td>Schema changes in source systems</td>
                    <td>Automated schema detection. Alert on mapping breaks. Maintain mapping versioning.</td>
                </tr>
                <tr>
                    <td>Data quality issues in sources</td>
                    <td>Implement quality checks in ETL. Flag issues but don't block pipeline. Alert data owners.</td>
                </tr>
                <tr>
                    <td>Complex entity resolution</td>
                    <td>Use ML for fuzzy matching. Maintain master identifier mapping table. Human-in-loop for conflicts.</td>
                </tr>
            </table>
        </div>

        <!-- Next Steps -->
        <div class="section">
            <h2>11. Get Started: First 30 Days</h2>

            <h3>Week 1: Setup & Planning</h3>
            <ol>
                <li>Provision Neo4j instance (cloud or local)</li>
                <li>Install Apache Airflow</li>
                <li>Document current ontology in OWL format</li>
                <li>Map ontology classes to Neo4j node labels</li>
                <li>Identify first data source for pilot</li>
            </ol>

            <h3>Week 2-3: Build First Pipeline</h3>
            <ol>
                <li>Write extraction query for pilot source</li>
                <li>Implement semantic transformation logic</li>
                <li>Create Neo4j load script</li>
                <li>Build Airflow DAG</li>
                <li>Test end-to-end on sample data</li>
            </ol>

            <h3>Week 4: Validate & Iterate</h3>
            <ol>
                <li>Run full load of historical data</li>
                <li>Verify ontology constraints in graph</li>
                <li>Build sample queries</li>
                <li>Create simple GraphQL API</li>
                <li>Demo to stakeholders</li>
            </ol>

            <div class="highlight-box">
                <strong>Success Criteria for First 30 Days:</strong>
                <ul>
                    <li>✅ Knowledge graph operational with 1 data source</li>
                    <li>✅ ETL pipeline running on schedule</li>
                    <li>✅ Can query using ontology terms</li>
                    <li>✅ Data quality validation working</li>
                    <li>✅ Stakeholders can access via API</li>
                </ul>
            </div>
        </div>

        <!-- Conclusion -->
        <div class="section" style="background: linear-gradient(135deg, #e0f2f1 0%, #b2dfdb 100%); border-left: 5px solid #00897b;">
            <h2>12. Why This Architecture Works</h2>
            <p style="font-size: 1.1em; line-height: 1.8;">
                By <strong>eliminating data virtualization</strong>, we've created a simpler, more maintainable architecture that's easier to understand and operate:
            </p>
            
            <ul style="font-size: 1.05em; line-height: 1.8;">
                <li><strong>Single direction data flow:</strong> Source DBs → ETL → Knowledge Graph → Applications</li>
                <li><strong>Standard patterns:</strong> ETL is well-understood by data engineering teams</li>
                <li><strong>Optimized for analytics:</strong> Graph database perfect for complex queries and ML</li>
                <li><strong>Clear ownership:</strong> Knowledge graph team owns data quality and freshness</li>
                <li><strong>Cost effective:</strong> Open-source tools for most components</li>
            </ul>

            <p style="font-size: 1.1em; line-height: 1.8;">
                The ontology still provides the <strong>semantic backbone</strong> - ensuring consistent understanding across the enterprise. But now it's <strong>physically materialized</strong> in a high-performance knowledge graph, ready for immediate use.
            </p>

            <div style="background: white; border-radius: 6px; padding: 20px; margin-top: 20px; text-align: center;">
                <p style="font-size: 1.3em; font-weight: 600; color: #00695c; margin: 0;">
                    Simpler Architecture = Faster Implementation = Earlier Value
                </p>
            </div>
        </div>

    </div>

</body>
</html>
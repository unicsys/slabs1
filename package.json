import requests
import urllib.parse
import json
import os

# --- Configuration ---
# All the settings you need to change are in this section.

# The server where your knowledge graph is hosted
MOBI_HOST = "https://localhost:8443"

# Your personal key to access the API.
API_TOKEN = "eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vbW9iaS5jb20vIiwic3ViIjoiYWRtaW4iLCJleHAiOjE3NjE3NjU4ODUsInNjb3BlIjoic2VsZiAvKiJ9.5COMLSTYdyzLutV2lz8A40inxCbLDZ0t5K01uE_ns-M"

# The specific dataset in the knowledge graph you want to query
RECORD_IRI = "https://mobi.com/records#96e3fd11-0fc5-4c15-b032-165fb2101976"

# This SPARQL query finds all defects recorded within a specific time window.
# Be sure to edit the dates in the FILTER clause below to match your needs.
SPARQL_QUERY = """
PREFIX ockms: <https://ontologyhub.rtx.com/RTXEnterpriseOntologies/OCKMSDigitalThreadOntology/>
PREFIX iof-core: <https://spec.industrialontologies.org/ontology/core/Core/>
PREFIX bfo: <http://purl.obolibrary.org/obo/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

SELECT ?datetime ?defectCode ?defectDesc ?componentPart ?refDes ?ccaPartNumber ?ccaSerial
WHERE {
  # Get defect recording process with time
  ?recProcess a ockms:DefectRecordingProcess ;
              bfo:BFO_0000199 ?instant ;
              iof-core:hasSpecifiedOutput ?classDesc .
  
  # Get datetime value
  ?timeValue a iof-core:TemporalInstantValueExpression ;
             iof-core:isValueExpressionOfAtSomeTime ?instant ;
             iof-core:hasDateTimeInstantValue ?datetime .
  
  # >> EDIT THIS LINE << - Change the start and end dates for your report
  FILTER(?datetime >= "2025-07-01T00:00:00"^^xsd:dateTime && ?datetime <= "2025-07-31T23:59:59"^^xsd:dateTime)
  
  # Get defect classification
  ?classDesc a ockms:DefectClassificationDescription ;
             iof-core:describes ?defect ;
             ockms:hasTextValue ?defectDesc .
  
  ?classCode a ockms:DefectClassificationCode ;
             iof-core:designates ?classDesc ;
             ockms:hasTextValue ?defectCode .
  
  # Get the defect
  ?defect a ockms:Defect .
  
  # Get electronic component that has this defect
  ?component a ockms:ElectronicComponent ;
             bfo:BFO_0000196 ?defect .
  
  # Get electronic component design (part number)
  ?compDesign a ockms:ElectronicComponentDesign ;
              iof-core:prescribes ?component .
  
  ?compDesignId a ockms:ElectronicComponentDesignIdentifier ;
                iof-core:designates ?compDesign ;
                ockms:hasTextValue ?componentPart .
  
  # Get reference designator (location)
  ?component bfo:BFO_0000171 ?location .
  
  ?refDesId a ockms:ReferenceDesignator ;
            iof-core:designates ?location ;
            ockms:hasTextValue ?refDes .
  
  # Get CCA serial number
  ?ccaId a ockms:CircuitCardAssemblyIdentifier ;
         iof-core:designates ?cca ;
         ockms:hasTextValue ?ccaSerial .
  
  ?cca a ockms:CircuitCardAssembly .
  
  # Get CCA design (part number)
  ?designRev a ockms:CircuitCardAssemblyDesignRevision ;
             iof-core:prescribes ?cca .
  
  ?design a ockms:CircuitCardAssemblyDesign ;
          bfo:BFO_0000110 ?designRev .
  
  ?designId a ockms:CircuitCardAssemblyDesignIdentifier ;
            iof-core:designates ?design ;
            ockms:hasTextValue ?ccaPartNumber .
}
ORDER BY ?datetime ?ccaSerial ?refDes
"""

def generate_html_report(results_json, filename="defect_report.html"):
    """
    Takes the SPARQL JSON result and generates a simple, self-contained HTML file.
    """
    try:
        headers = results_json['head']['vars']
        bindings = results_json['results']['bindings']

        # Start building the HTML string
        html = f"""
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Defect Report</title>
            <style>
                body {{ font-family: sans-serif; }}
                table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
                th, td {{ border: 1px solid #dddddd; text-align: left; padding: 8px; }}
                th {{ background-color: #f2f2f2; }}
                tr:nth-child(even) {{ background-color: #f9f9f9; }}
                h1 {{ color: #333; }}
            </style>
        </head>
        <body>
            <h1>Defect Report</h1>
        """

        if not bindings:
            html += "<p>Query returned no results.</p>"
        else:
            html += "<table>\n"
            # Create table header
            html += "  <thead>\n    <tr>\n"
            for header in headers:
                html += f"      <th>{header}</th>\n"
            html += "    </tr>\n  </thead>\n"

            # Create table body
            html += "  <tbody>\n"
            for item in bindings:
                html += "    <tr>\n"
                for header in headers:
                    value = item.get(header, {}).get('value', 'N/A')
                    html += f"      <td>{value}</td>\n"
                html += "    </tr>\n"
            html += "  </tbody>\n"
            html += "</table>"
        
        html += """
        </body>
        </html>
        """

        # Write the HTML string to a file
        with open(filename, 'w') as f:
            f.write(html)
        
        # Get the full path for a more helpful message
        full_path = os.path.abspath(filename)
        print(f"\nSuccessfully created HTML report!")
        print(f"Report saved to: {full_path}")

    except (KeyError, TypeError) as e:
        print(f"Could not parse the JSON response to create HTML. Error: {e}")


# --- Main Script ---

# Build the full URL for the API endpoint
encoded_iri = urllib.parse.quote(RECORD_IRI, safe='')
url = f"{MOBI_HOST}/mobirest/sparql/dataset-record/{encoded_iri}/limited-results"

# Prepare the headers for our request
headers = {
    'Cookie': f'mobi_web_token={API_TOKEN}',
    'Accept': 'application/json',
    'Content-Type': 'application/x-www-form-urlencoded'
}

print(f"Sending SPARQL query to: {RECORD_IRI}")

try:
    # Disable warnings for self-signed certificates in development
    requests.packages.urllib3.disable_warnings()
    
    # Send the request to the server
    response = requests.post(url, headers=headers, data={'query': SPARQL_QUERY}, verify=False)
    
    # Raise an error if the request failed
    response.raise_for_status()
    
    # If successful, parse the JSON and generate the HTML report
    results = response.json()
    generate_html_report(results)

except requests.exceptions.RequestException as e:
    print(f"\nError during API request: {e}")
    if hasattr(e, 'response') and e.response:
        print(f"Server response: {e.response.text}")

except json.JSONDecodeError:
    print("\nError: Could not decode the server's JSON response.")
    print("--- Raw Response Text ---")
    print(response.text)
